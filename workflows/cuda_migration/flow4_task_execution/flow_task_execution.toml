flow_name = "代码执行"
flow_type = "LOOP"
description =  '''
## 任务执行
当前工作流的目标是执行任务，完成目标函数或者模块的代码CUDA迁移工作，包括代码查询，代码生成，代码编辑，代码构建与调试。
'''
# 循环执行参数
[loop]
dependencies = ['flow3.node4']
mode = "Iteration"
prompt = '''
将任务分解，将需要迁移的模块，根据要求格式化输出，形成任务列表，便于后续遍历执行。每个子任务请详细描述任务内容。
每个子任务描述需要遵循如下的模板（<namespace>，<class_name>和<method>需要根据实际情况替换）：1. 将<namespace>::<class_name>::<method>方法中耗时的代码，封装到名字空间<namespace>中的cuda函数<class_name>_<method>_kernel中；在名字空间<namespace>内实现接口函数<class_name>_<method>_cuda，该函数负责调用<class_name>_<method>_kernel，数据传输，以及CUDA核函数错误检查，同时，该接口函数作为C++代码中访问CUDA版本的接口。2. <class_name>_<method>_cuda和<class_name>_<method>_kernel两个函数的实现保存至src/cuda_kernels/<class_name>_<method>.cu文件中，<class_name>_<method>_cuda的声明保存至src/cuda_kernels/<class_name>_<method>.h文件中。3. 在<namespace>::<class_name>::<method>方法所在的文件，判断如果定义了ENABLE_CUDA，则添加#include "src/cuda_kernels/<class_name>_<method>.h"，同时在该方法中需要通过宏定义ENABLE_CUDA选择调用原始函数实现还是调用<class_name>_<method>_cuda。
'''

[iterative_development]
max_repeat_count = 3


[[nodes]]
id = "node1"
name = "任务相关代码查询"
inputs = []
config = "node1_config_QueryCode.toml"

[[nodes]]
id = "node2"
name = "代码生成"
inputs = ["node1"]
config = "node2_config_genCode.toml"

[[nodes]]
id = "node3"
name = "编辑代码"
inputs = ["node2"]
config = "node3_config_editCode.toml"

[[nodes]]
id = "node4"
name = "构建调试"
inputs = ["node3"]
config = "node4_config_debugCode.toml"
